[/
    Copyright 2014-2015, Chris Glover

    Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
]

[section Preface]

Inheritance is probably the most overused abstraction in C++ and indeed most
modern languages.  Despite the fact that most problems don't fit into such a
nice hierarchy, most programmers reach for inheritance too soon when first
building a new system resulting in overly rigid architcturses that are
difficult to change. There must be a better way.

[warning entity is still very young and changing constantly.  I doubt it's
useful for anything real just yet.  But, please, give it a go and let me know
how it can be improved. ]

[h2 Description]

'entity' is the realization of a bet made with a co-worker that it would be
possible to adequately abstract away the concept of entity/component
relationships in a way that doesn't impose a large runtime performance
penalty.  The result is this library, where, if used correclty can handle all
sorts of entity/component arrangements with little or no peformance overhead.

'entity' implements a method to compose object-like things from component-link
things in a dynamic, yet typesafe fashion.  Such a system is usually refered
to as en Entity-Component system.  Several interesting properties come from
such a design such as increased performance and reduced memory usage.

[tip For more information on what and Entity/Component system is, you can read
about it on Wikipedia under __ecs__ 
]

[h2 Motivation]

While here are several entity/component systems already in existence for C++,
they all suffer from the same issue; the component list is carried with the
entity which creates a performance issue in code trying to get components.

'entity' takes a different approach. Here, an entity is an identifier (an int-
like thing)  and a component is any type with corresponding entry in an array
somewhere. This simple approach leads to a near zero performance penalty for
the abstraction with the only caveat being that the code must have access to
the pools as well as the entity in order to do any work on a specific
component.  In other systems, if you have access to the entity, you have
access to any components that might be attached to it.

An interesting side effect of the design in this library is that it puts to
programmer back in control of access rights because one can hide pools that
should not be accessed from other systems.  This also allows multiple
instances of the same component type per entity, something that some __ecs__
systems forbit.  For other entity systems, everything on the entity is
essentially global to the entity.

With regards to the pools themselves, entity makes no attempt to manage them.
Instead, this library focuses on managing the comunication between the various
pools and entitys for lifetime management such that the programmer is freed
from having to worry about this.  The idea is similar to that of constructors
and destructors.

[h2 Influences and Related Work]

There are several implementations of __ecs__ systems in C++ and other languages. Most widely used is probably the one in the __unity__ game engine.

[endsect]